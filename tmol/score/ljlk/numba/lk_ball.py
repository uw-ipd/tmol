"""Baseline implicit desolvation implementation."""

import toolz

import numpy
import numba

import tmol.numeric.interpolation.cubic_hermite_polynomial as cubic_hermite_polynomial
from tmol.score.chemical_database import AcceptorHybridization

from .common import dist, lj_sigma

from .lk_isotropic import lk_isotropic_pair, d_lk_isotropic_pair_d_dist


jit = toolz.curry(numba.jit)(nopython=True, nogil=True)

interpolate = jit(cubic_hermite_polynomial.interpolate)
interpolate_dx = jit(cubic_hermite_polynomial.interpolate_dx)
interpolate_to_zero = jit(cubic_hermite_polynomial.interpolate_to_zero)
interpolate_to_zero_dx = jit(cubic_hermite_polynomial.interpolate_to_zero_dx)


# cross product (numpy.cross not supported by numba)
@jit
def cross(a, b):
    result = numpy.zeros(3)
    result[0] = a[1] * b[2] - a[2] * b[1]
    result[1] = a[2] * b[0] - a[0] * b[2]
    result[2] = a[0] * b[1] - a[1] * b[0]
    return result


# matrix/vector multiplication (numpy.matmul not supported by numba)
@jit
def mult_matrix_vector(A, b):
    m, n = A.shape
    c = numpy.zeros(m)
    for i in range(0, m):
        for j in range(0, n):
            c[i] += A[i, j] * b[j]
    return c


# build a donor water off a d-h group
#  h: donor H
#  d: donor heavy
@jit
def build_don_water(d, h, dist):
    dir = h - d
    dir = dir / numpy.sqrt(numpy.dot(dir, dir))
    return d + dist * dir


#   dWdatm[i,j,k] gives datm_i.j/dwater_k
#     i is indexed d,h
#     j,k are indexed over cartesian x,y,z
# auto-generated by sympy (see notebook dev/lk_ball.ipynb)
@jit
def d_don_water_datom(d, h, dist):
    dh = h - d
    dh2 = dh * dh

    dhx = -d[0] + h[0]
    dhx2 = dhx * dhx
    dhy = -d[1] + h[1]
    dhy2 = dhy * dhy
    dhz = -d[2] + h[2]
    dhz2 = dhz * dhz
    dh2 = dhx2 + dhy2 + dhz2
    dist_norm = dist / numpy.sqrt(dh2)
    dist_norm_deriv = dist_norm / dh2

    dwda = numpy.zeros((2, 3, 3))
    dwda[0, 0, 0] = dhx2 * dist_norm / dh2 + (1 - dist_norm)
    dwda[0, 0, 1] = dhy * dhx * dist_norm_deriv
    dwda[0, 0, 2] = dhz * dhx * dist_norm_deriv
    dwda[0, 1, 0] = dhy * dhx * dist_norm_deriv
    dwda[0, 1, 1] = dhy2 * dist_norm_deriv + (1 - dist_norm)
    dwda[0, 1, 2] = dhz * dhy * dist_norm_deriv
    dwda[0, 2, 0] = dhz * dhx * dist_norm_deriv
    dwda[0, 2, 1] = dhz * dhy * dist_norm_deriv
    dwda[0, 2, 2] = dhz2 * dist_norm_deriv + (1 - dist_norm)
    dwda[1, 0, 0] = dist_norm - dhx * dist_norm_deriv * dhx
    dwda[1, 0, 1] = -dhy * dist_norm_deriv * dhx
    dwda[1, 0, 2] = -dhx * dhz * dist_norm_deriv
    dwda[1, 1, 0] = -dhx * dist_norm_deriv * dhy
    dwda[1, 1, 1] = dist_norm - dhy * dist_norm_deriv * dhy
    dwda[1, 1, 2] = -dhz * dist_norm_deriv * dhy
    dwda[1, 2, 0] = -dhx * dist_norm_deriv * dhz
    dwda[1, 2, 1] = -dhy * dist_norm_deriv * dhz
    dwda[1, 2, 2] = dist_norm - dhz * dist_norm_deriv * dhz
    return dwda


# build acceptor waters off a polar group defined by three atoms:
#  a: acceptor
#  b: "base" of a
# b0: "base0" of a
@jit
def build_acc_waters(a, b, b0, dist, angle, tors):
    M = numpy.empty((3, 3))
    M[:, 0] = a - b
    M[:, 0] = M[:, 0] / numpy.sqrt(numpy.dot(M[:, 0], M[:, 0]))
    M[:, 1] = b0 - b
    M[:, 2] = cross(M[:, 0], M[:, 1])
    M2norm = numpy.sqrt(numpy.dot(M[:, 2], M[:, 2]))
    if M2norm == 0:
        # if a/b/c collinear, set M[:,2] to an arbitrary vector perp to M[:,0]
        if M[0, 0] != 1:
            M[:, 1] = numpy.array((1, 0, 0))
            M[:, 2] = cross(M[:, 0], M[:, 1])
        else:
            M[:, 1] = numpy.array((0, 1, 0))
            M[:, 2] = cross(M[:, 0], M[:, 1])
        M2norm = numpy.sqrt(numpy.dot(M[:, 2], M[:, 2]))
    M[:, 2] = M[:, 2] / M2norm
    M[:, 1] = cross(M[:, 2], M[:, 0])

    # build waters
    nwats = len(tors)
    waters = numpy.empty((nwats, 3))
    for i in range(nwats):
        waters[i, :] = numpy.array(
            [
                dist * numpy.cos(numpy.pi - angle),
                dist * numpy.sin(numpy.pi - angle) * numpy.cos(tors[i]),
                dist * numpy.sin(numpy.pi - angle) * numpy.sin(tors[i]),
            ]
        )
        waters[i, :] = mult_matrix_vector(M, waters[i, :]) + a

    return waters


# return a 3 x 3 x nwat x 3 matrix dWdatm where
#   dWdatm[i,j,k,l] gives datm_i.j/dwater_k.l
#     i is indexed a,b,b0
#     k is indexed 0..nwat
#     j,l are indexed over cartesian x,y,z
# auto-generated by sympy (see notebook dev/lk_ball.ipynb)
# @jit
def d_acc_waters_datom(A, B, B0, dist, angle, torsions):
    dWdA = numpy.zeros((3, 3, len(torsions), 3))
    for i, torsion in enumerate(torsions):
        x101 = -B[2]
        x102 = A[2] + x101
        x103 = -B[0]
        x104 = B0[0] + x103
        x105 = A[0] + x103
        x106 = x105 * x105
        x107 = -B[1]
        x108 = A[1] + x107
        x109 = x108 * x108
        x110 = x102 * x102
        x111 = x106 + x109 + x110
        x112 = 1 / numpy.sqrt(x111)
        x113 = x104 * x112
        x114 = B0[2] + x101
        x115 = x112 * x114
        x116 = x102 * x113 - x105 * x115
        x117 = B0[1] + x107
        x118 = x112 * x117
        x119 = x105 * x118 - x108 * x113
        x120 = -x102 * x118 + x108 * x115
        x121 = x116 * x116 + x119 * x119 + x120 * x120
        x122 = 1 / numpy.sqrt(x121)
        x123 = x111 ** (-1.5)
        x124 = x123 * (-A[0] + B[0])
        x125 = x122 * x124
        x126 = x102 * x125
        x127 = x108 * x125
        x128 = x108 * x112
        x129 = x105 * x124
        x130 = x117 * x129
        x131 = x104 * x124
        x132 = x108 * x131
        x133 = x122 * (x118 + x130 - x132)
        x134 = -x115
        x135 = x102 * x131
        x136 = x114 * x129
        x137 = x134 + x135 - x136
        x138 = x102 * x112
        x139 = x122 * x138
        x140 = x116 * x138
        x141 = x121 ** (-1.5)
        x142 = x108 * x114
        x143 = x124 * x142
        x144 = x102 * x117
        x145 = x124 * x144
        x146 = x120 / 2
        x147 = 2 * x118
        x148 = x119 / 2
        x149 = 2 * x115
        x150 = -x149
        x151 = x116 / 2
        x152 = x141 * (
            -x146 * (2 * x143 - 2 * x145)
            - x148 * (2 * x130 - 2 * x132 + x147)
            - x151 * (2 * x135 - 2 * x136 + x150)
        )
        x153 = x119 * x128
        x154 = torsion
        x155 = numpy.pi - angle
        x156 = dist * numpy.sin(x155)
        x157 = x156 * numpy.cos(x154)
        x158 = dist * numpy.cos(x155)
        x159 = x143 - x145
        x160 = x156 * numpy.sin(x154)
        x161 = x122 * x160
        x162 = x152 * x160
        x163 = x112 * x158
        x164 = x163 + 1
        x165 = x124 * x158
        x166 = x112 * x122
        x167 = x119 * x166
        x168 = x122 * x129
        x169 = x105 * x112
        x170 = x119 * x169
        x171 = x120 * x138
        x172 = x116 * x166
        x173 = -x172
        x174 = x122 * x128
        x175 = x122 * x169
        x176 = x120 * x128
        x177 = x116 * x169
        x178 = x123 * (-A[1] + B[1])
        x179 = x105 * x178
        x180 = x142 * x178
        x181 = x144 * x178
        x182 = x115 + x180 - x181
        x183 = x114 * x179
        x184 = x104 * x178
        x185 = x102 * x184
        x186 = 2 * x113
        x187 = -x186
        x188 = x117 * x179
        x189 = x108 * x184
        x190 = x141 * (
            -x146 * (x149 + 2 * x180 - 2 * x181)
            - x148 * (x187 + 2 * x188 - 2 * x189)
            - x151 * (-2 * x183 + 2 * x185)
        )
        x191 = x160 * x190
        x192 = -x167
        x193 = x122 * x178
        x194 = x102 * x193
        x195 = x108 * x193
        x196 = -x183 + x185
        x197 = -x113
        x198 = x188 - x189 + x197
        x199 = x122 * x179
        x200 = x158 * x178
        x201 = x120 * x166
        x202 = x123 * (-A[2] + B[2])
        x203 = x105 * x202
        x204 = -x118
        x205 = x142 * x202
        x206 = x144 * x202
        x207 = x204 + x205 - x206
        x208 = x117 * x203
        x209 = x104 * x202
        x210 = x108 * x209
        x211 = x114 * x203
        x212 = x102 * x209
        x213 = -x147
        x214 = x141 * (
            -x146 * (2 * x205 - 2 * x206 + x213)
            - x148 * (2 * x208 - 2 * x210)
            - x151 * (x186 - 2 * x211 + 2 * x212)
        )
        x215 = x160 * x214
        x216 = x122 * x202
        x217 = x102 * x216
        x218 = x108 * x216
        x219 = x208 - x210
        x220 = x113 - x211 + x212
        x221 = x158 * x202
        x222 = -x201
        x223 = x122 * x203
        x224 = -x163
        x225 = x106 * x123
        x226 = x105 * x123
        x227 = x142 * x226
        x228 = x144 * x226
        x229 = x227 - x228
        x230 = 2 * x227
        x231 = 2 * x228
        x232 = 2 * x128
        x233 = x117 * x225
        x234 = x104 * x226
        x235 = x108 * x234
        x236 = 2 * x138
        x237 = x114 * x225
        x238 = x102 * x234
        x239 = x141 * (
            -x146 * (x230 - x231)
            - x148 * (x213 + x232 + 2 * x233 - 2 * x235)
            - x151 * (x149 - x236 - 2 * x237 + 2 * x238)
        )
        x240 = x160 * x239
        x241 = x102 * x226
        x242 = x122 * x241
        x243 = x116 * x242
        x244 = x108 * x226
        x245 = x122 * x244
        x246 = x119 * x245
        x247 = x115 - x138 - x237 + x238
        x248 = x128 + x204 + x233 - x235
        x249 = x158 * x244
        x250 = x122 * x225
        x251 = x158 * x241
        x252 = x109 * x123
        x253 = x114 * x252
        x254 = x108 * x123
        x255 = x144 * x254
        x256 = x134 + x138 + x253 - x255
        x257 = x102 * x254
        x258 = x104 * x257
        x259 = 2 * x258
        x260 = 2 * x169
        x261 = x104 * x252
        x262 = x117 * x244
        x263 = x141 * (
            -x146 * (x150 + x236 + 2 * x253 - 2 * x255)
            - x148 * (x186 - x260 - 2 * x261 + 2 * x262)
            - x151 * (-x230 + x259)
        )
        x264 = x160 * x263
        x265 = x122 * x252
        x266 = x122 * x257
        x267 = -x227 + x258
        x268 = x113 - x169 - x261 + x262
        x269 = x120 * x266
        x270 = x158 * x257
        x271 = x110 * x123
        x272 = x117 * x271
        x273 = x102 * x123 * x142
        x274 = x118 - x128 - x272 + x273
        x275 = x104 * x271
        x276 = x114 * x241
        x277 = x141 * (
            -x146 * (x147 - x232 - 2 * x272 + 2 * x273)
            - x148 * (x231 - x259)
            - x151 * (x187 + x260 + 2 * x275 - 2 * x276)
        )
        x278 = x160 * x277
        x279 = x122 * x271
        x280 = x228 - x258
        x281 = x169 + x197 + x275 - x276
        x282 = x141 * (-x140 + x153)
        x283 = x160 * x282
        x284 = x122 / x111
        x285 = x109 * x284
        x286 = x110 * x284
        x287 = x139 * x160
        x288 = x105 * x284
        x289 = -x108 * x288
        x290 = x160 * x174
        x291 = -x102 * x288
        x292 = x141 * (-x170 + x171)
        x293 = x160 * x292
        x294 = x106 * x284
        x295 = x160 * x175
        x296 = -x102 * x108 * x284
        x297 = x141 * (-x176 + x177)
        x298 = x160 * x297
        dWdA[0, 0, i, 0] = (
            x120 * x162
            + x129 * x158
            + x157
            * (
                x116 * x126
                - x119 * x127
                - x128 * x133
                + x137 * x139
                + x140 * x152
                - x152 * x153
            )
            + x159 * x161
            + x164
        )
        dWdA[0, 0, i, 1] = (
            x108 * x165
            + x116 * x162
            + x137 * x161
            + x157
            * (
                x119 * x168
                - x120 * x126
                + x133 * x169
                - x139 * x159
                + x152 * x170
                - x152 * x171
                + x167
            )
        )
        dWdA[0, 0, i, 2] = (
            x102 * x165
            + x119 * x162
            + x133 * x160
            + x157
            * (
                -x116 * x168
                + x120 * x127
                - x137 * x175
                + x152 * x176
                - x152 * x177
                + x159 * x174
                + x173
            )
        )
        dWdA[0, 1, i, 0] = (
            x120 * x191
            + x157
            * (
                x116 * x194
                - x119 * x195
                + x139 * x196
                + x140 * x190
                - x153 * x190
                - x174 * x198
                + x192
            )
            + x158 * x179
            + x161 * x182
        )
        dWdA[0, 1, i, 1] = (
            x108 * x200
            + x116 * x191
            + x157
            * (
                x119 * x199
                - x120 * x194
                - x139 * x182
                + x170 * x190
                - x171 * x190
                + x175 * x198
            )
            + x161 * x196
            + x164
        )
        dWdA[0, 1, i, 2] = (
            x102 * x200
            + x119 * x191
            + x157
            * (
                -x116 * x199
                + x120 * x195
                + x174 * x182
                - x175 * x196
                + x176 * x190
                - x177 * x190
                + x201
            )
            + x161 * x198
        )
        dWdA[0, 2, i, 0] = (
            x120 * x215
            + x157
            * (
                x116 * x217
                - x119 * x218
                + x139 * x220
                + x140 * x214
                - x153 * x214
                + x172
                - x174 * x219
            )
            + x158 * x203
            + x161 * x207
        )
        dWdA[0, 2, i, 1] = (
            x108 * x221
            + x116 * x215
            + x157
            * (
                x119 * x223
                - x120 * x217
                - x139 * x207
                + x170 * x214
                - x171 * x214
                + x175 * x219
                + x222
            )
            + x161 * x220
        )
        dWdA[0, 2, i, 2] = (
            x102 * x221
            + x119 * x215
            + x157
            * (
                -x116 * x223
                + x120 * x218
                + x174 * x207
                - x175 * x220
                + x176 * x214
                - x177 * x214
            )
            + x161 * x219
            + x164
        )
        dWdA[1, 0, i, 0] = (
            x120 * x240
            + x157
            * (x139 * x247 + x140 * x239 - x153 * x239 - x174 * x248 + x243 - x246)
            + x158 * x225
            + x161 * x229
            + x224
        )
        dWdA[1, 0, i, 1] = (
            x116 * x240
            + x157
            * (
                x119 * x250
                - x120 * x242
                - x139 * x229
                + x170 * x239
                - x171 * x239
                + x175 * x248
                + x192
            )
            + x161 * x247
            + x249
        )
        dWdA[1, 0, i, 2] = (
            x119 * x240
            + x157
            * (
                -x116 * x250
                + x120 * x245
                + x172
                + x174 * x229
                - x175 * x247
                + x176 * x239
                - x177 * x239
            )
            + x161 * x248
            + x251
        )
        dWdA[1, 1, i, 0] = (
            x120 * x264
            + x157
            * (
                x116 * x266
                - x119 * x265
                + x139 * x267
                + x140 * x263
                - x153 * x263
                + x167
                - x174 * x268
            )
            + x161 * x256
            + x249
        )
        dWdA[1, 1, i, 1] = (
            x116 * x264
            + x157
            * (-x139 * x256 + x170 * x263 - x171 * x263 + x175 * x268 + x246 - x269)
            + x158 * x252
            + x161 * x267
            + x224
        )
        dWdA[1, 1, i, 2] = (
            x119 * x264
            + x157
            * (
                -x116 * x245
                + x120 * x265
                + x174 * x256
                - x175 * x267
                + x176 * x263
                - x177 * x263
                + x222
            )
            + x161 * x268
            + x270
        )
        dWdA[1, 2, i, 0] = (
            x120 * x278
            + x157
            * (
                x116 * x279
                - x119 * x266
                + x139 * x281
                + x140 * x277
                - x153 * x277
                + x173
                - x174 * x280
            )
            + x161 * x274
            + x251
        )
        dWdA[1, 2, i, 1] = (
            x116 * x278
            + x157
            * (
                x119 * x242
                - x120 * x279
                - x139 * x274
                + x170 * x277
                - x171 * x277
                + x175 * x280
                + x201
            )
            + x161 * x281
            + x270
        )
        dWdA[1, 2, i, 2] = (
            x119 * x278
            + x157
            * (x174 * x274 - x175 * x281 + x176 * x277 - x177 * x277 - x243 + x269)
            + x158 * x271
            + x161 * x280
            + x224
        )
        dWdA[2, 0, i, 0] = x120 * x283 + x157 * (
            x140 * x282 - x153 * x282 + x285 + x286
        )
        dWdA[2, 0, i, 1] = (
            x116 * x283 + x157 * (x170 * x282 - x171 * x282 + x289) + x287
        )
        dWdA[2, 0, i, 2] = (
            x119 * x283 + x157 * (x176 * x282 - x177 * x282 + x291) - x290
        )
        dWdA[2, 1, i, 0] = (
            x120 * x293 + x157 * (x140 * x292 - x153 * x292 + x289) - x287
        )
        dWdA[2, 1, i, 1] = x116 * x293 + x157 * (
            x170 * x292 - x171 * x292 + x286 + x294
        )
        dWdA[2, 1, i, 2] = (
            x119 * x293 + x157 * (x176 * x292 - x177 * x292 + x296) + x295
        )
        dWdA[2, 2, i, 0] = (
            x120 * x298 + x157 * (x140 * x297 - x153 * x297 + x291) + x290
        )
        dWdA[2, 2, i, 1] = (
            x116 * x298 + x157 * (x170 * x297 - x171 * x297 + x296) - x295
        )
        dWdA[2, 2, i, 2] = x119 * x298 + x157 * (
            x176 * x297 - x177 * x297 + x285 + x294
        )
    return dWdA


# build all waters for a given conformation
# fd: we could probably be more clever with returned data structure,
#     it is currently inefficient
@jit
def build_all_waters(
    coords,
    atom_types,
    is_acceptor,
    is_donor,
    acceptor_hybridization,
    attached_h,
    base_atoms,
    lkb_water_dist,
    lkb_water_angle_sp2,
    lkb_water_angle_sp3,
    lkb_water_angle_ring,
    lkb_water_tors_sp2,
    lkb_water_tors_sp3,
    lkb_water_tors_ring,
    waters,
    nwaters,
):
    for i in range(coords.shape[0]):
        ti = atom_types[i]
        if is_acceptor[ti]:
            # FD this block should instead query a list of bonds
            b, b0 = base_atoms[i, :]
            if acceptor_hybridization[ti] == AcceptorHybridization.sp2:
                wat_ang = lkb_water_angle_sp2
                wat_tors = lkb_water_tors_sp2
                Xb, Xb0 = coords[b], coords[b0]
            elif acceptor_hybridization[ti] == AcceptorHybridization.sp3:
                wat_ang = lkb_water_angle_sp3
                wat_tors = lkb_water_tors_sp3
                Xb, Xb0 = coords[b], coords[b0]
            elif acceptor_hybridization[ti] == AcceptorHybridization.ring:
                wat_ang = lkb_water_angle_ring
                wat_tors = lkb_water_tors_ring
                Xb = 0.5 * (coords[b] + coords[b0])
                Xb0 = coords[b0]

            n_to_build = len(wat_tors)
            waters[i, nwaters[i] : nwaters[i] + n_to_build, :] = build_acc_waters(
                coords[i], Xb, Xb0, lkb_water_dist, wat_ang, wat_tors
            )
            nwaters[i] += n_to_build

        if is_donor[ti]:
            for h in attached_h[i, :]:
                if h > -1:
                    waters[i, nwaters[i], :] = build_don_water(
                        coords[i], coords[h], lkb_water_dist
                    )
                    nwaters[i] += 1


# get the fraction of occlusion assigned to waters
#   1 if perfect overlap
#   0 if far from the water
# use a softmax to combine interactions from multiple waters
# @jit
def get_lk_fraction(atom_i, ramp_width_A2, lj_radius_i, waters_j):
    d2_low = max(0, numpy.square(1.4 + lj_radius_i) - ramp_width_A2)
    wted_d2_delta = 0
    for wj in waters_j:
        delta_ij = atom_i - wj
        d2_delta = numpy.dot(delta_ij, delta_ij) - d2_low
        wted_d2_delta += numpy.exp(-d2_delta / 1.0)
    wted_d2_delta = -1.0 * numpy.log(wted_d2_delta)

    frac = 0
    if wted_d2_delta < 0:
        frac = 1
    elif wted_d2_delta < ramp_width_A2:
        frac = numpy.square(1 - numpy.square(wted_d2_delta / ramp_width_A2))
    return frac


# derivatives of lk_fraction w.r.t. water / atom positions
# @jit
def get_dlk_fraction_dij(atom_i, ramp_width_A2, lj_radius_i, waters_j):
    d2_low = max(0, numpy.square(1.4 + lj_radius_i) - ramp_width_A2)

    nwat = waters_j.shape[0]

    wted_d2_delta = 0
    dwted_d2_delta_dai = numpy.zeros((3))
    dwted_d2_delta_dwj = numpy.zeros((nwat, 3))

    for i, wj in enumerate(waters_j):
        delta_ij = atom_i - wj
        d2_delta = numpy.dot(delta_ij, delta_ij) - d2_low
        exp_d2_delta = numpy.exp(-d2_delta / 1.0)
        dwted_d2_delta_dwj[i, :] = -2 * exp_d2_delta * delta_ij
        dwted_d2_delta_dai += 2 * exp_d2_delta * delta_ij
        wted_d2_delta += exp_d2_delta

    dwted_d2_delta_dwj = dwted_d2_delta_dwj / wted_d2_delta
    dwted_d2_delta_dai = dwted_d2_delta_dai / wted_d2_delta

    wted_d2_delta = -1.0 * numpy.log(wted_d2_delta)

    dfrac_dwted_d2 = 0
    if wted_d2_delta > 0 and wted_d2_delta < ramp_width_A2:
        dfrac_dwted_d2 = -(
            4
            * wted_d2_delta
            * (numpy.square(ramp_width_A2) - numpy.square(wted_d2_delta))
            / numpy.square(numpy.square(ramp_width_A2))
        )

    dwted_d2_delta_dwj = dfrac_dwted_d2 * dwted_d2_delta_dwj
    dwted_d2_delta_dai = dfrac_dwted_d2 * dwted_d2_delta_dai

    return (dwted_d2_delta_dai, dwted_d2_delta_dwj)


# get the fraction of occlusion assigned to water-water overlap
#   1 if perfect overlap
#   0 if far
# use a softmax to combine interactions from multiple waters
# additionally includes a base-atom distance component
# @jit
def get_lkbr_fraction(
    atom_i,
    atom_j,
    overlap_gap_A2,
    overlap_width_A2,
    waters_i,
    waters_j,
    heavyatom_water_len,
):
    # water overlap
    wted_d2_delta = 0
    for wi in waters_i:
        for wj in waters_j:
            delta_ij = wi - wj
            d2_delta = numpy.dot(delta_ij, delta_ij) - overlap_gap_A2
            wted_d2_delta += numpy.exp(-d2_delta / 1.0)
    wted_d2_delta = -1.0 * numpy.log(wted_d2_delta)

    frac = 0
    if wted_d2_delta < 0:
        frac = 1
    elif wted_d2_delta < overlap_width_A2:
        frac = numpy.square(1 - numpy.square(wted_d2_delta / overlap_width_A2))

    # base angle
    overlap_target_len2 = 8.0 / 3.0 * numpy.square(heavyatom_water_len)
    delta_ij = atom_i - atom_j
    overlap_len2 = numpy.dot(delta_ij, delta_ij)
    base_atom_delta = numpy.abs(overlap_len2 - overlap_target_len2)
    angle_overlap_A2 = 2.8 * overlap_width_A2

    if base_atom_delta > angle_overlap_A2:
        frac = 0
    else:
        frac *= numpy.square(1 - numpy.square(base_atom_delta / angle_overlap_A2))

    return frac


# derivatives of lk_bridge fraction w.r.t. water / atom positions
def get_dlkbr_fraction_dij(
    atom_i,
    atom_j,
    overlap_gap_A2,
    overlap_width_A2,
    waters_i,
    waters_j,
    heavyatom_water_len,
):
    nwat_i = waters_i.shape[0]
    nwat_j = waters_j.shape[0]

    wted_d2_delta = 0
    dwted_d2_delta_dai = numpy.zeros((3))
    dwted_d2_delta_daj = numpy.zeros((3))
    dwted_d2_delta_dwi = numpy.zeros((nwat_i, 3))
    dwted_d2_delta_dwj = numpy.zeros((nwat_j, 3))

    # water overlap
    for i, wi in enumerate(waters_i):
        for j, wj in enumerate(waters_j):
            delta_ij = wi - wj
            d2_delta = numpy.dot(delta_ij, delta_ij) - overlap_gap_A2
            exp_d2_delta = numpy.exp(-d2_delta / 1.0)
            dwted_d2_delta_dwi[i, :] += 2 * exp_d2_delta * delta_ij
            dwted_d2_delta_dwj[j, :] -= 2 * exp_d2_delta * delta_ij
            wted_d2_delta += exp_d2_delta

    dwted_d2_delta_dwi = dwted_d2_delta_dwi / wted_d2_delta
    dwted_d2_delta_dwj = dwted_d2_delta_dwj / wted_d2_delta

    wted_d2_delta = -1.0 * numpy.log(wted_d2_delta)

    # TODO unknown variable?
    # dfrac_dwted_d2 = 0

    overlapfrac = 0
    if wted_d2_delta < 0:
        overlapfrac = 1
    elif wted_d2_delta < overlap_width_A2:
        overlapfrac = numpy.square(1 - numpy.square(wted_d2_delta / overlap_width_A2))
        doverlapfrac_dwted_d2 = -(
            4
            * wted_d2_delta
            * (numpy.square(overlap_width_A2) - numpy.square(wted_d2_delta))
            / numpy.square(numpy.square(overlap_width_A2))
        )

    # base angle
    overlap_target_len2 = 8.0 / 3.0 * numpy.square(heavyatom_water_len)
    delta_ij = atom_i - atom_j
    overlap_len2 = numpy.dot(delta_ij, delta_ij)
    base_atom_delta = overlap_len2 - overlap_target_len2
    angle_overlap_A2 = 2.8 * overlap_width_A2
    dwted_d2_delta_dai = 2 * delta_ij
    dwted_d2_delta_daj = -2 * delta_ij

    anglefrac = 0.0
    danglefrac_dbasedelta = 0.0
    if numpy.abs(base_atom_delta) > angle_overlap_A2:
        anglefrac = 0
        danglefrac_dbasedelta = 0
    elif numpy.abs(base_atom_delta) > 0:
        anglefrac = numpy.square(1 - numpy.square(base_atom_delta / angle_overlap_A2))
        danglefrac_dbasedelta = -(
            4
            * base_atom_delta
            * (numpy.square(angle_overlap_A2) - numpy.square(base_atom_delta))
            / numpy.square(numpy.square(angle_overlap_A2))
        )
    else:
        anglefrac = 1
        danglefrac_dbasedelta = 0

    # final scaling
    dwted_d2_delta_dai = overlapfrac * danglefrac_dbasedelta * dwted_d2_delta_dai
    dwted_d2_delta_daj = overlapfrac * danglefrac_dbasedelta * dwted_d2_delta_daj
    dwted_d2_delta_dwi = anglefrac * doverlapfrac_dwted_d2 * dwted_d2_delta_dwi
    dwted_d2_delta_dwj = anglefrac * doverlapfrac_dwted_d2 * dwted_d2_delta_dwj

    return (
        dwted_d2_delta_dai,
        dwted_d2_delta_daj,
        dwted_d2_delta_dwi,
        dwted_d2_delta_dwj,
    )


# two-way lk-ball energy calculation (i-desolv-j and j-desolv-i)
# returns four values, unweighted:
#   (lkball_iso, lkball, lkbridge, lkbridge_uncpl)
# @jit
def lkball_pair(
    dist,
    bonded_path_length,
    lj_sigma_ij,
    atom_i,
    lkb_waters_i,
    lj_radius_i,
    lk_dgfree_i,
    lk_lambda_i,
    lk_volume_i,
    atom_j,
    lkb_waters_j,
    lj_radius_j,
    lk_dgfree_j,
    lk_lambda_j,
    lk_volume_j,
    heavyatom_water_len,
):
    # parameters
    overlap_gap_A2 = 0.5
    overlap_width_A2 = 2.6
    ramp_width_A2 = 3.709

    # early exit if too far apart
    max_lkb_dist = (
        6.0
        + 2 * heavyatom_water_len
        + numpy.sqrt(overlap_gap_A2 + overlap_width_A2)
        + 0.1
    )
    if dist > max_lkb_dist:
        return (0, 0, 0, 0)

    # get lk energies and lkball fraction
    lk_j_desolv_i, frac_j_desolv_i = 0, 0
    if len(lkb_waters_j) > 0:
        lk_j_desolv_i = lk_isotropic_pair(
            dist,
            bonded_path_length,
            lj_sigma_ij,
            lj_radius_j,
            lk_dgfree_j,
            lk_lambda_j,
            lj_radius_i,
            lk_volume_i,
        )
        frac_j_desolv_i = get_lk_fraction(
            atom_i, ramp_width_A2, lj_radius_i, lkb_waters_j
        )

    lk_i_desolv_j, frac_i_desolv_j = 0, 0
    if len(lkb_waters_i) > 0:
        lk_i_desolv_j = lk_isotropic_pair(
            dist,
            bonded_path_length,
            lj_sigma_ij,
            lj_radius_i,
            lk_dgfree_i,
            lk_lambda_i,
            lj_radius_j,
            lk_volume_j,
        )
        frac_i_desolv_j = get_lk_fraction(
            atom_j, ramp_width_A2, lj_radius_j, lkb_waters_i
        )

    # lkbridge (water/water interactions)
    frac_i_j_water_overlap = 0
    if len(lkb_waters_i) > 0 and len(lkb_waters_j) > 0:
        frac_i_j_water_overlap = get_lkbr_fraction(
            atom_i,
            atom_j,
            overlap_gap_A2,
            overlap_width_A2,
            lkb_waters_i,
            lkb_waters_j,
            heavyatom_water_len,
        )

    e_lk_ball_iso = lk_i_desolv_j + lk_j_desolv_i
    e_lk_ball = lk_i_desolv_j * frac_i_desolv_j + lk_j_desolv_i * frac_j_desolv_i
    e_lk_bridge = (lk_i_desolv_j + lk_j_desolv_i) * frac_i_j_water_overlap
    e_lk_bridge_uncpl = frac_i_j_water_overlap

    return (e_lk_ball_iso, e_lk_ball, e_lk_bridge, e_lk_bridge_uncpl)


# return the derivatives of the lk energy terms w.r.t. atom and water positions
# returns tuples:
#    dlk/dai, dlk/daj, dlk/dwatersi, dlk/dwatersj
# last index of each corresponds to the four subterms
# @jit
def dlkball_pair_dij(
    dist,
    bonded_path_length,
    lj_sigma_ij,
    atom_i,
    lkb_waters_i,
    lj_radius_i,
    lk_dgfree_i,
    lk_lambda_i,
    lk_volume_i,
    atom_j,
    lkb_waters_j,
    lj_radius_j,
    lk_dgfree_j,
    lk_lambda_j,
    lk_volume_j,
    heavyatom_water_len,
):
    # parameters
    overlap_gap_A2 = 0.5
    overlap_width_A2 = 2.6
    ramp_width_A2 = 3.709

    # return types
    nwat_i = lkb_waters_i.shape[0]
    nwat_j = lkb_waters_j.shape[0]
    dlk_dai = numpy.zeros((3, 4))
    dlk_daj = numpy.zeros((3, 4))
    dlk_dwi = numpy.zeros((nwat_i, 3, 4))
    dlk_dwj = numpy.zeros((nwat_j, 3, 4))

    # early exit if too far apart
    max_lkb_dist = (
        6.0
        + 2 * heavyatom_water_len
        + numpy.sqrt(overlap_gap_A2 + overlap_width_A2)
        + 0.1
    )
    if dist > max_lkb_dist:
        return (dlk_dai, dlk_daj, dlk_dwi, dlk_dwj)

    vec_ij = atom_i - atom_j
    d_d_d_i = vec_ij / dist
    d_d_d_j = -vec_ij / dist

    # get lk energies and lkball fraction
    #   and derivatives of both
    lk_j_desolv_i, frac_j_desolv_i = 0, 0
    dlk_j_desolv_i_ddist = numpy.zeros(3)
    dfrac_j_desolv_i_dai = numpy.zeros(3)
    dfrac_j_desolv_i_dwj = numpy.zeros((nwat_j, 3))
    if len(lkb_waters_j) > 0:
        lk_j_desolv_i = lk_isotropic_pair(
            dist,
            bonded_path_length,
            lj_sigma_ij,
            lj_radius_j,
            lk_dgfree_j,
            lk_lambda_j,
            lj_radius_i,
            lk_volume_i,
        )
        dlk_j_desolv_i_ddist = d_lk_isotropic_pair_d_dist(
            dist,
            bonded_path_length,
            lj_sigma_ij,
            lj_radius_j,
            lk_dgfree_j,
            lk_lambda_j,
            lj_radius_i,
            lk_volume_i,
        )

        frac_j_desolv_i = get_lk_fraction(
            atom_i, ramp_width_A2, lj_radius_i, lkb_waters_j
        )
        dfrac_j_desolv_i_dai, dfrac_j_desolv_i_dwj = get_dlk_fraction_dij(
            atom_i, ramp_width_A2, lj_radius_i, lkb_waters_j
        )

    lk_i_desolv_j, frac_i_desolv_j = 0, 0
    dlk_i_desolv_j_ddist = numpy.zeros(3)
    dfrac_i_desolv_j_daj = numpy.zeros(3)
    dfrac_i_desolv_j_dwi = numpy.zeros((nwat_i, 3))
    if len(lkb_waters_i) > 0:
        lk_i_desolv_j = lk_isotropic_pair(
            dist,
            bonded_path_length,
            lj_sigma_ij,
            lj_radius_i,
            lk_dgfree_i,
            lk_lambda_i,
            lj_radius_j,
            lk_volume_j,
        )
        dlk_i_desolv_j_ddist = d_lk_isotropic_pair_d_dist(
            dist,
            bonded_path_length,
            lj_sigma_ij,
            lj_radius_i,
            lk_dgfree_i,
            lk_lambda_i,
            lj_radius_j,
            lk_volume_j,
        )

        frac_i_desolv_j = get_lk_fraction(
            atom_j, ramp_width_A2, lj_radius_j, lkb_waters_i
        )
        dfrac_i_desolv_j_daj, dfrac_i_desolv_j_dwi = get_dlk_fraction_dij(
            atom_j, ramp_width_A2, lj_radius_j, lkb_waters_i
        )

    # lkbridge (water/water interactions)
    frac_i_j_water_overlap = 0
    dfrac_i_j_water_overlap_dai = numpy.zeros(3)
    dfrac_i_j_water_overlap_daj = numpy.zeros(3)
    dfrac_i_j_water_overlap_dwi = numpy.zeros((nwat_i, 3))
    dfrac_i_j_water_overlap_dwj = numpy.zeros((nwat_j, 3))
    if len(lkb_waters_i) > 0 and len(lkb_waters_j) > 0:
        frac_i_j_water_overlap = get_lkbr_fraction(
            atom_i,
            atom_j,
            overlap_gap_A2,
            overlap_width_A2,
            lkb_waters_i,
            lkb_waters_j,
            heavyatom_water_len,
        )

        (
            dfrac_i_j_water_overlap_dai,
            dfrac_i_j_water_overlap_daj,
            dfrac_i_j_water_overlap_dwi,
            dfrac_i_j_water_overlap_dwj,
        ) = get_dlkbr_fraction_dij(
            atom_i,
            atom_j,
            overlap_gap_A2,
            overlap_width_A2,
            lkb_waters_i,
            lkb_waters_j,
            heavyatom_water_len,
        )

    dlk_i_desolv_j_dai = dlk_i_desolv_j_ddist * numpy.array(d_d_d_i)
    dlk_i_desolv_j_daj = dlk_i_desolv_j_ddist * numpy.array(d_d_d_j)
    dlk_j_desolv_i_dai = dlk_j_desolv_i_ddist * numpy.array(d_d_d_i)
    dlk_j_desolv_i_daj = dlk_j_desolv_i_ddist * numpy.array(d_d_d_j)

    # e_lk_ball_iso = lk_i_desolv_j + lk_j_desolv_i
    dlk_dai[:, 0] = dlk_i_desolv_j_dai + dlk_j_desolv_i_dai
    dlk_daj[:, 0] = dlk_i_desolv_j_daj + dlk_j_desolv_i_daj

    # e_lk_ball = lk_i_desolv_j * frac_i_desolv_j + lk_j_desolv_i * frac_j_desolv_i
    dlk_dai[:, 1] = (
        dlk_i_desolv_j_dai * frac_i_desolv_j
        + dlk_j_desolv_i_dai * frac_j_desolv_i
        + lk_j_desolv_i * dfrac_j_desolv_i_dai
    )
    dlk_daj[:, 1] = (
        dlk_i_desolv_j_daj * frac_i_desolv_j
        + lk_i_desolv_j * dfrac_i_desolv_j_daj
        + dlk_j_desolv_i_daj * frac_j_desolv_i
    )
    dlk_dwi[:, :, 1] = lk_i_desolv_j * dfrac_i_desolv_j_dwi
    dlk_dwj[:, :, 1] = lk_j_desolv_i * dfrac_j_desolv_i_dwj

    # e_lk_bridge = (lk_i_desolv_j + lk_j_desolv_i) * frac_i_j_water_overlap
    dlk_dai[:, 2] = (lk_i_desolv_j + lk_j_desolv_i) * dfrac_i_j_water_overlap_dai + (
        dlk_i_desolv_j_dai + dlk_j_desolv_i_dai
    ) * frac_i_j_water_overlap
    dlk_daj[:, 2] = (lk_i_desolv_j + lk_j_desolv_i) * dfrac_i_j_water_overlap_daj + (
        dlk_i_desolv_j_daj + dlk_j_desolv_i_daj
    ) * frac_i_j_water_overlap
    dlk_dwi[:, :, 2] = (lk_i_desolv_j + lk_j_desolv_i) * dfrac_i_j_water_overlap_dwi
    dlk_dwj[:, :, 2] = (lk_i_desolv_j + lk_j_desolv_i) * dfrac_i_j_water_overlap_dwj

    # e_lk_bridge_uncpl = frac_i_j_water_overlap
    dlk_dai[:, 3] = dfrac_i_j_water_overlap_dai
    dlk_daj[:, 3] = dfrac_i_j_water_overlap_daj
    dlk_dwi[:, :, 3] = dfrac_i_j_water_overlap_dwi
    dlk_dwj[:, :, 3] = dfrac_i_j_water_overlap_dwj

    return (dlk_dai, dlk_daj, dlk_dwi, dlk_dwj)


# @jit
def lkball(
    dist,
    atom_i,
    atom_j,
    bonded_path_length,
    lkb_waters_i,
    lj_radius_i,
    lk_dgfree_i,
    lk_lambda_i,
    lk_volume_i,
    is_donor_i,
    is_hydroxyl_i,
    is_polarh_i,
    is_acceptor_i,
    lkb_waters_j,
    lj_radius_j,
    lk_dgfree_j,
    lk_lambda_j,
    lk_volume_j,
    is_donor_j,
    is_hydroxyl_j,
    is_polarh_j,
    is_acceptor_j,
    lj_hbond_dis,
    lj_hbond_OH_donor_dis,
    lj_hbond_hdis,
    heavyatom_water_len,
):
    lj_sigma_ij = lj_sigma(
        lj_radius_i,
        is_donor_i,
        is_hydroxyl_i,
        is_polarh_i,
        is_acceptor_i,
        lj_radius_j,
        is_donor_j,
        is_hydroxyl_j,
        is_polarh_j,
        is_acceptor_j,
        lj_hbond_dis,
        lj_hbond_OH_donor_dis,
        lj_hbond_hdis,
    )

    return lkball_pair(
        dist,
        bonded_path_length,
        lj_sigma_ij,
        atom_i,
        lkb_waters_i,
        lj_radius_i,
        lk_dgfree_i,
        lk_lambda_i,
        lk_volume_i,
        atom_j,
        lkb_waters_j,
        lj_radius_j,
        lk_dgfree_j,
        lk_lambda_j,
        lk_volume_j,
        heavyatom_water_len,
    )


# @jit
def dlkball_dij(
    dist,
    atom_i,
    atom_j,
    bonded_path_length,
    lkb_waters_i,
    lj_radius_i,
    lk_dgfree_i,
    lk_lambda_i,
    lk_volume_i,
    is_donor_i,
    is_hydroxyl_i,
    is_polarh_i,
    is_acceptor_i,
    lkb_waters_j,
    lj_radius_j,
    lk_dgfree_j,
    lk_lambda_j,
    lk_volume_j,
    is_donor_j,
    is_hydroxyl_j,
    is_polarh_j,
    is_acceptor_j,
    lj_hbond_dis,
    lj_hbond_OH_donor_dis,
    lj_hbond_hdis,
    heavyatom_water_len,
):
    lj_sigma_ij = lj_sigma(
        lj_radius_i,
        is_donor_i,
        is_hydroxyl_i,
        is_polarh_i,
        is_acceptor_i,
        lj_radius_j,
        is_donor_j,
        is_hydroxyl_j,
        is_polarh_j,
        is_acceptor_j,
        lj_hbond_dis,
        lj_hbond_OH_donor_dis,
        lj_hbond_hdis,
    )

    return dlkball_pair_dij(
        dist,
        bonded_path_length,
        lj_sigma_ij,
        atom_i,
        lkb_waters_i,
        lj_radius_i,
        lk_dgfree_i,
        lk_lambda_i,
        lk_volume_i,
        atom_j,
        lkb_waters_j,
        lj_radius_j,
        lk_dgfree_j,
        lk_lambda_j,
        lk_volume_j,
        heavyatom_water_len,
    )


def lkball_intra(
    coords,
    atom_types,
    bonded_path_lengths,
    attached_h,  # new
    base_atoms,  # new
    lj_radius,
    lk_dgfree,
    lk_lambda,
    lk_volume,
    acceptor_hybridization,  # new
    is_donor,
    is_hydroxyl,
    is_polarh,
    is_acceptor,
    lj_hbond_dis,
    lj_hbond_OH_donor_dis,
    lj_hbond_hdis,
    lkb_water_dist,  # new
    lkb_water_angle_sp2,  # new
    lkb_water_angle_sp3,  # new
    lkb_water_angle_ring,  # new
    lkb_water_tors_sp2,  # new
    lkb_water_tors_sp3,  # new
    lkb_water_tors_ring,  # new
):
    nc = coords.shape[0]
    nout = int((nc * (nc - 1)) / 2)

    oinds = numpy.empty((nout, 2), dtype=numpy.int64)
    oval = numpy.empty((nout, 4), dtype=coords.dtype)  # 4 subterms

    # PASS 1: build waters
    waters = numpy.full((coords.shape[0], 4, 3), numpy.nan)
    nwaters = numpy.zeros((coords.shape[0]), dtype=numpy.int64)
    build_all_waters(
        coords,
        atom_types,
        is_acceptor,
        is_donor,
        acceptor_hybridization,
        attached_h,
        base_atoms,
        lkb_water_dist,
        lkb_water_angle_sp2,
        lkb_water_angle_sp3,
        lkb_water_angle_ring,
        lkb_water_tors_sp2,
        lkb_water_tors_sp3,
        lkb_water_tors_ring,
        waters,
        nwaters,
    )

    # PASS 2: calc energies
    v = 0
    for i in range(nc):
        for j in range(i + 1, nc):
            if nwaters[i] + nwaters[j] == 0:
                continue

            ti = atom_types[i]
            tj = atom_types[j]
            val_ij = lkball(
                dist(coords[i], coords[j]),
                coords[i],
                coords[j],
                bonded_path_lengths[i, j],
                waters[i, : nwaters[i], :],
                lj_radius[ti],
                lk_dgfree[ti],
                lk_lambda[ti],
                lk_volume[ti],
                is_donor[ti],
                is_hydroxyl[ti],
                is_polarh[ti],
                is_acceptor[ti],
                waters[j, : nwaters[j], :],
                lj_radius[tj],
                lk_dgfree[tj],
                lk_lambda[tj],
                lk_volume[tj],
                is_donor[tj],
                is_hydroxyl[tj],
                is_polarh[tj],
                is_acceptor[tj],
                lj_hbond_dis,
                lj_hbond_OH_donor_dis,
                lj_hbond_hdis,
                lkb_water_dist,
            )

            if val_ij[0] == 0 and val_ij[1] == 0 and val_ij[2] == 0 and val_ij[3] == 0:
                continue

            oinds[v, 0] = i
            oinds[v, 1] = j
            oval[v] = val_ij

            v += 1

    return oinds[:v], oval[:v]


def lkball_intra_backward(
    inds,
    d_val,
    coords,
    atom_types,
    bonded_path_lengths,
    attached_h,
    base_atoms,
    lj_radius,
    lk_dgfree,
    lk_lambda,
    lk_volume,
    acceptor_hybridization,
    is_donor,
    is_hydroxyl,
    is_polarh,
    is_acceptor,
    lj_hbond_dis,
    lj_hbond_OH_donor_dis,
    lj_hbond_hdis,
    lkb_water_dist,
    lkb_water_angle_sp2,
    lkb_water_angle_sp3,
    lkb_water_angle_ring,
    lkb_water_tors_sp2,
    lkb_water_tors_sp3,
    lkb_water_tors_ring,
):
    nc = coords.shape[0]

    # PASS 1: build waters
    waters = numpy.full((coords.shape[0], 4, 3), numpy.nan)
    nwaters = numpy.zeros((coords.shape[0]), dtype=numpy.int64)
    build_all_waters(
        coords,
        atom_types,
        is_acceptor,
        is_donor,
        acceptor_hybridization,
        attached_h,
        base_atoms,
        lkb_water_dist,
        lkb_water_angle_sp2,
        lkb_water_angle_sp3,
        lkb_water_angle_ring,
        lkb_water_tors_sp2,
        lkb_water_tors_sp3,
        lkb_water_tors_ring,
        waters,
        nwaters,
    )

    # PASS 2: calc and sum derivs
    dE_datm = numpy.zeros((nc, 3, 4))
    dE_dwat = numpy.zeros((nc, 4, 3, 4))
    for v in range(inds.shape[0]):
        i = inds[v, 0]
        j = inds[v, 1]

        ti = atom_types[i]
        tj = atom_types[j]

        (dlk_dai, dlk_daj, dlk_dwi, dlk_dwj) = dlkball_dij(
            dist(coords[i], coords[j]),
            coords[i],
            coords[j],
            bonded_path_lengths[i, j],
            waters[i, : nwaters[i], :],
            lj_radius[ti],
            lk_dgfree[ti],
            lk_lambda[ti],
            lk_volume[ti],
            is_donor[ti],
            is_hydroxyl[ti],
            is_polarh[ti],
            is_acceptor[ti],
            waters[j, : nwaters[j], :],
            lj_radius[tj],
            lk_dgfree[tj],
            lk_lambda[tj],
            lk_volume[tj],
            is_donor[tj],
            is_hydroxyl[tj],
            is_polarh[tj],
            is_acceptor[tj],
            lj_hbond_dis,
            lj_hbond_OH_donor_dis,
            lj_hbond_hdis,
            lkb_water_dist,
        )
        dE_datm[i, ...] += dlk_dai
        dE_datm[j, ...] += dlk_daj
        dE_dwat[i, : nwaters[i], ...] += dlk_dwi
        dE_dwat[j, : nwaters[j], ...] += dlk_dwj

    # PASS 3: map water derivs -> atom derivs
    for i in range(nc):
        nwaters_i = 0
        ti = atom_types[i]
        if is_acceptor[ti]:
            # FD this block should instead query a list of bonds
            b, b0 = base_atoms[i, :]
            bscale = 1.0
            if acceptor_hybridization[ti] == AcceptorHybridization.sp2:
                wat_ang = lkb_water_angle_sp2
                wat_tors = lkb_water_tors_sp2
                Xb, Xb0 = coords[b], coords[b0]
            elif acceptor_hybridization[ti] == AcceptorHybridization.sp3:
                wat_ang = lkb_water_angle_sp3
                wat_tors = lkb_water_tors_sp3
                Xb, Xb0 = coords[b], coords[b0]
            elif acceptor_hybridization[ti] == AcceptorHybridization.ring:
                wat_ang = lkb_water_angle_ring
                wat_tors = lkb_water_tors_ring
                Xb = 0.5 * (coords[b] + coords[b0])
                Xb0 = coords[b0]

            n_to_build = len(wat_tors)
            dWdA = d_acc_waters_datom(
                coords[i], Xb, Xb0, lkb_water_dist, wat_ang, wat_tors
            )
            for j in range(n_to_build):
                for term in range(4):
                    dE_datm[i, :, term] += mult_matrix_vector(
                        dWdA[0, :, j, :], dE_dwat[i, j, :, term]
                    )

                    # there is probably a cleaner way to do this...
                    if acceptor_hybridization[ti] == AcceptorHybridization.ring:
                        dbb0_dwat = mult_matrix_vector(
                            dWdA[1, :, j, :], dE_dwat[i, j, :, term]
                        )
                        dE_datm[b, :, term] += 0.5 * dbb0_dwat
                        dE_datm[b0, :, term] += 0.5 * dbb0_dwat
                    else:
                        dE_datm[b, :, term] += mult_matrix_vector(
                            dWdA[1, :, j, :], dE_dwat[i, j, :, term]
                        )
                        dE_datm[b0, :, term] += mult_matrix_vector(
                            dWdA[2, :, j, :], dE_dwat[i, j, :, term]
                        )
            nwaters_i += n_to_build

        if is_donor[ti]:
            for h in attached_h[i, :]:
                if h > -1:
                    dWdA = d_don_water_datom(coords[i], coords[h], lkb_water_dist)
                    for term in range(4):
                        dE_datm[i, :, term] += mult_matrix_vector(
                            dWdA[0, :, :], dE_dwat[i, nwaters_i, :, term]
                        )
                        dE_datm[h, :, term] += bscale * mult_matrix_vector(
                            dWdA[1, :, :], dE_dwat[i, nwaters_i, :, term]
                        )

                    nwaters_i += 1

    return dE_datm
