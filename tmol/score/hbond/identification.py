import attr
import cattr
import toolz

from tmol.types.functional import convert_args
from tmol.types.attrs import ValidateAttrs
from tmol.types.array import NDArray

import numpy
import pandas

from tmol.database.scoring import HBondDatabase

acceptor_dtype = numpy.dtype([
    ("a", int),
    ("b", int),
    ("b0", int),
    ("acceptor_type", object),
])

donor_dtype = numpy.dtype([
    ("d", int),
    ("h", int),
    ("donor_type", object),
])


def merge_tables(*tables, **kwargs):
    assert len(tables) >= 2
    return toolz.reduce(toolz.curry(pandas.merge, **kwargs), tables)


def df_to_struct(df, column_mapping):
    """Convert a subset of columns into a structured array."""
    df_subset = df[list(column_mapping.keys())].rename(columns=column_mapping)

    numpy_record_table = df_subset.to_records(index=False)
    return numpy_record_table.view(numpy_record_table.dtype.fields)


@attr.s(frozen=True, slots=True, auto_attribs=True)
class HBondElementAnalysis(ValidateAttrs):
    """Atom indicies for hbond donors and acceptors within system.

    Atom indicies for hbond elements, form of atom sets defining:

    Donors:
    1) hbond donors
    2) sp2-hybridized hbond acceptors
    3) sp3-hybridized hbond acceptors
    4) ring-hybridized hbond acceptors

    Elements are identified by matching bonding pattern and atom type against
    the set of defined donor/acceptor element types in the source hbond score
    database.

    Bond graph matching uses sql-like joins provided by the pandas package in
    order to do graph matching: e.g.,

    "I have atoms a, b, and c that are bonded in a pattern
    of a-b and b-c and I know their chemical types as ta, tb, and tc; do these three
    atoms match any of the known sets of sp2 hybridized acceptors?"
    """

    donors: NDArray(donor_dtype)[:]
    sp2_acceptors: NDArray(acceptor_dtype)[:]
    sp3_acceptors: NDArray(acceptor_dtype)[:]
    ring_acceptors: NDArray(acceptor_dtype)[:]

    @classmethod
    @convert_args
    def setup(
            cls,
            hbond_database: HBondDatabase,
            atom_types: NDArray(object)[:],
            bonds: NDArray(int)[:, 2],
    ):
        """Perform element analysis over the given bonded atom types.

        ``atom_types`` includes string atom types for atoms in the system
        ``bonds`` includes atom type indices (in atom_types) for bonds in the system

        Bond graph matching proceeds in two phases:

        1) The bond graph is processed to a generate frames of bonded atom
        pairs/triples, without pruning by atom type, generating a table of
        *every* pair/triple in the structure.

        2) The source HBondDatabase is unstructured and converted into frames
        of bonded-atom-type pairs/triples, tagged with the element type of the
        atom type pair/triple, generating a table of every known hbond element
        type and it's corresponding atom types.

        3) The bonded-atom pairs/triples are inner joined against the element
        pairs/triples by atom type, generating a table of pairs/triples for
        which an hbond element type is defined.
        """

        atom_types = pandas.Categorical(atom_types)

        # Generate bond arrangement tables containing:
        #   atom_index '*_a'
        #   atom_type  '*_t'
        #   # of bonds '*_nbond'
        #
        # with column names i, j [and later k]

        # Bonded-atom-triples (e.g. i-j-k, or k-i-j) are generated by
        # self-joining the pair-table after relabeling via `inc_cols`.  Varying
        # `inc-cols` invocations are used to generate the i-j, j-k, and i-k
        # bond pairs, which are then joined into property index bonded triples.

        def inc_cols(table, *cols):
            order = {"i": "j", "j": "k"}
            res = []
            for n in cols:
                nn = order[n]
                res.append((n + "_a", nn + "_a"))
                res.append((n + "_t", nn + "_t"))
                res.append((n + "_nbond", nn + "_nbond"))
            return table.rename(columns=dict(res))

        bond_table = pandas.DataFrame.from_dict({
            "i_a": bonds[:, 0],
            "i_t": atom_types[bonds[:, 0]],
            "j_a": bonds[:, 1],
            "j_t": atom_types[bonds[:, 1]],
        })

        # Calculate bond counts for each atom then merge by the atom index
        bond_table = merge_tables(
            bond_table,
            bond_table["i_a"].value_counts().to_frame("i_nbond")
            .rename_axis("i_a").reset_index(),
            bond_table["j_a"].value_counts().to_frame("j_nbond")
            .rename_axis("j_a").reset_index(),
        )

        # Index of bond arragments of the form:
        #
        #    i---j
        #
        bond_pair_table = bond_table

        # Index of all bonded arrangments of the form:
        #
        #   i---j
        #    \
        #     k
        #
        # pruned by unique atom types on j & k
        bond_sibling_table = (
            merge_tables(
                bond_table.query("i_nbond == 2"),
                inc_cols(bond_table, "j"),
            )
            .query("j_a != k_a")
            .drop_duplicates(("i_a", "j_t", "k_t"))
        ) # yapf: disable

        # Index of all arrangments of the form:
        #
        #   i---j---?
        #        \
        #         k
        #
        # pruned by unique atom types on k
        bond_parent_table = (
            merge_tables(
                bond_table.query("i_nbond == 1"),
                inc_cols(bond_table, "i", "j"),
            )
            .query("i_a != k_a")
            .drop_duplicates(("i_a", "k_t"))
        ) # yapf: disable

        if hbond_database.atom_groups.donors:
            # Identify donors by donor-hydrogen bonds:
            #
            #   d---h
            #
            # by matching atom types.

            donor_types = pandas.DataFrame.from_records(
                cattr.unstructure(hbond_database.atom_groups.donors)
            )[["d", "h", "donor_type"]]
            donor_table = pandas.merge(
                donor_types,
                bond_pair_table,
                how="inner",
                left_on=["d", "h"],
                right_on=["i_t", "j_t"]
            )
            donors = df_to_struct(
                donor_table, {
                    "i_a": "d",
                    "j_a": "h",
                    "donor_type": "donor_type"
                }
            )
        else:
            donors = numpy.empty(0, donor_dtype)

        if hbond_database.atom_groups.sp2_acceptors:
            # Identify sp2 by acceptor-base-base0
            #
            #   a---b---?
            #        \
            #         b0
            #
            # by matching atom types.
            sp2_acceptor_types = pandas.DataFrame.from_records(
                cattr.unstructure(hbond_database.atom_groups.sp2_acceptors)
            )
            sp2_acceptor_table = pandas.merge(
                sp2_acceptor_types,
                bond_parent_table,
                how="inner",
                left_on=["a", "b", "b0"],
                right_on=["i_t", "j_t", "k_t"]
            )
            sp2_acceptors = df_to_struct(
                sp2_acceptor_table, {
                    "i_a": "a",
                    "j_a": "b",
                    "k_a": "b0",
                    "acceptor_type": "acceptor_type"
                }
            )
        else:
            sp2_acceptors = numpy.empty(0, acceptor_dtype)

        if hbond_database.atom_groups.sp3_acceptors:
            # Identify sp3 by acceptor-base-base0
            #
            #   a---b
            #    \
            #     b0
            #
            # by matching atom types.
            sp3_acceptor_types = pandas.DataFrame.from_records(
                cattr.unstructure(hbond_database.atom_groups.sp3_acceptors)
            )
            sp3_acceptor_table = pandas.merge(
                sp3_acceptor_types,
                bond_sibling_table,
                how="inner",
                left_on=["a", "b", "b0"],
                right_on=["i_t", "j_t", "k_t"]
            )
            sp3_acceptors = df_to_struct(
                sp3_acceptor_table, {
                    "i_a": "a",
                    "j_a": "b",
                    "k_a": "b0",
                    "acceptor_type": "acceptor_type"
                }
            )
        else:
            sp3_acceptors = numpy.empty(0, acceptor_dtype)

        if hbond_database.atom_groups.ring_acceptors:
            # Identify ring by acceptor-base-base0
            #
            #   a---b
            #    \
            #     b0
            #
            # by matching atom types.
            ring_acceptor_types = pandas.DataFrame.from_records(
                cattr.unstructure(hbond_database.atom_groups.ring_acceptors)
            )
            ring_acceptor_table = pandas.merge(
                ring_acceptor_types,
                bond_sibling_table,
                how="inner",
                left_on=["a", "b", "b0"],
                right_on=["i_t", "j_t", "k_t"]
            )
            ring_acceptors = df_to_struct(
                ring_acceptor_table, {
                    "i_a": "a",
                    "j_a": "b",
                    "k_a": "b0",
                    "acceptor_type": "acceptor_type"
                }
            )
        else:
            ring_acceptors = numpy.empty(0, acceptor_dtype)

        return cls(
            donors=donors,
            sp2_acceptors=sp2_acceptors,
            sp3_acceptors=sp3_acceptors,
            ring_acceptors=ring_acceptors,
        )
