import torch
import numpy
import toolz

from typing import List, Mapping
from tmol.types.functional import validate_args
from tmol.types.torch import Tensor
from tmol.chemical.restypes import ResidueTypeSet
from tmol.database import ParameterDatabase
from tmol.io.canonical_ordering import CanonicalOrdering
from tmol.pose.packed_block_types import PackedBlockTypes
from tmol.pose.pose_stack import PoseStack


@validate_args
def pose_stack_from_rosettafold2(
    seq: Tensor[torch.int64][:],
    xyz: Tensor[torch.float32][:, :, 3],
    chainlens: List,
    **kwargs,
) -> PoseStack:
    """Build a PoseStack from the output generated by RoseTTAFold2

    This function will build a PoseStack using a limited set of
    residue type: only the canonical amino acids with the canonical
    n- and c-termini patches. It begins by constructing a "canonical
    form" and then passes that canonical form to the
    pose_stack_from_canonical_form function. See
    canonical_form_from_openfold (below) for details
    on this intermediate representation and how it might be
    useful to you.

    Additional arguments to pose_stack_from_canonical_form may be
    passed through this function using the kwargs.
    """
    from tmol.io.pose_stack_construction import pose_stack_from_canonical_form

    cf = canonical_form_from_rosettafold2(seq, xyz, chainlens)

    co = canonical_ordering_for_rosettafold2()
    pbt = packed_block_types_for_rosettafold2(cf["coords"].device)

    return pose_stack_from_canonical_form(co, pbt, **cf, **kwargs)


@validate_args
def canonical_form_from_rosettafold2(
    seq: Tensor[torch.int64][:], xyz: Tensor[torch.float32][:, :, 3], chainlens: List
) -> Mapping:
    """The canonical form is intended to represent a stable, serializable intermediate format
    for a structure so that it can be created today and then be read in years from now
    and be used to construct a PoseStack in tmol. As residue types are integers,
    this means that we must guarantee stability of these integer representations, but it also
    means that you the user must build a PoseStack using the carefully constructed objects
    returned by the canonical_ordering_for_rosettafold2 and packed_block_types_for_rosettafold2
    functions.

    E.g.:
        seq, xyz, chainlens = rosettafold2_model.infer(sequence)
        cf = tmol.canonical_form_from_rosettafold2(seq, xyz, chainlens)
        torch.save(cf, "saved_canonical_form.pt")

        # then later
        cf2 = {x: y.to(device) for x,y in torch.load("saved_canonical_form.pt")}
        co = canonical_ordering_for_rosettafold2()
        pbt = packed_block_types_for_rosettafold2(device)
        pose_stack = tmol.pose_stack_from_canonical_form(co, pbt, **cf2)

    """

    device = xyz.device
    n_poses = 1  # RF2 does not presently do batch processing
    max_n_res = seq.shape[0]
    max_n_ats = xyz.shape[1]

    rf2_pose_ind_for_atom = (
        torch.arange(n_poses, dtype=torch.int64, device=device)
        .reshape(-1, 1, 1)
        .expand(-1, max_n_res, max_n_ats)
    )
    rf2_res_ind_for_atom = (
        torch.arange(max_n_res, dtype=torch.int64, device=device)
        .reshape(1, -1, 1)
        .expand(n_poses, -1, max_n_ats)
    )

    assert device == seq.device

    co = canonical_ordering_for_rosettafold2()
    (
        rf22t_rtmap,
        rf22t_atmap,
        rf2_at_is_real_map,
        supress_atom_for_nterm,
    ) = _get_rf2_2_tmol_mappings(device)

    seq = seq.unsqueeze(0)
    xyz = xyz.unsqueeze(0)
    tmol_restypes = rf22t_rtmap[seq]
    atom_mapping = rf22t_atmap[seq]
    rf2_at_is_real = rf2_at_is_real_map[seq]

    tmol_coords = torch.full(
        (n_poses, max_n_res, co.max_n_canonical_atoms, 3),
        numpy.nan,
        dtype=torch.float32,
        device=device,
    )
    tmol_coords[
        rf2_pose_ind_for_atom[rf2_at_is_real],
        rf2_res_ind_for_atom[rf2_at_is_real],
        atom_mapping[rf2_at_is_real],
    ] = xyz[rf2_at_is_real]

    chain_id = torch.zeros((max_n_res,), dtype=torch.int32, device=device)
    if len(chainlens) > 1:
        t_chainlens = torch.tensor(chainlens[:-1], dtype=torch.int64, device=device)
        chainbegins = torch.cumsum(t_chainlens, dim=0)
        chain_id[chainbegins] = 1
        chain_id = torch.cumsum(chain_id, dim=0, dtype=torch.int32)
    chain_id = chain_id.unsqueeze(0)

    # Now let's turn off the H atoms for any n-term residues
    supress_atom = torch.zeros(
        (n_poses, max_n_res, co.max_n_canonical_atoms), dtype=torch.bool, device=device
    )
    nterm_res = torch.zeros((max_n_res,), dtype=torch.bool, device=device)
    nterm_res[0] = True
    if len(chainlens) > 1:
        nterm_res[chainbegins] = True
    supress_atom = supress_atom_for_nterm[seq]
    nterm_atom = (
        nterm_res.unsqueeze(0)
        .unsqueeze(2)
        .expand(n_poses, -1, co.max_n_canonical_atoms)
    )
    supress = torch.logical_and(supress_atom, nterm_atom)
    tmol_coords[supress] = numpy.nan

    return dict(
        chain_id=chain_id,
        res_types=tmol_restypes.to(torch.int32),
        coords=tmol_coords,
    )


def pose_stack_to_rosettafold2_with_suppressed(pose_stack, chainlens):
    from tmol.io.pose_stack_deconstruction import canonical_form_from_pose_stack

    device = pose_stack.device
    n_poses = 1  # RF2 does not presently do batch processing
    max_n_res = sum(chainlens)
    max_n_ats = 27

    rf2_pose_ind_for_atom = (
        torch.arange(n_poses, dtype=torch.int64, device=device)
        .reshape(-1, 1, 1)
        .expand(-1, max_n_res, max_n_ats)
    )
    rf2_res_ind_for_atom = (
        torch.arange(max_n_res, dtype=torch.int64, device=device)
        .reshape(1, -1, 1)
        .expand(n_poses, -1, max_n_ats)
    )

    co = canonical_ordering_for_rosettafold2()
    (
        _,  # rf22t_rtmap,
        rf22t_atmap,
        rf2_at_is_real_map,
        supress_atom_for_nterm,
        hydrogens,
        h_to_h1,
    ) = _get_tmol_2_rf2_mappings(device)

    # torch.set_printoptions(threshold=10_000, linewidth=256)

    canonical_form = canonical_form_from_pose_stack(co, pose_stack)

    seq = canonical_form[1]
    atom_mapping = rf22t_atmap[seq]
    hydro = hydrogens[seq]
    h1s = h_to_h1[seq]
    supressed = supress_atom_for_nterm[seq]
    rf2_at_is_real = rf2_at_is_real_map[seq]

    rf2_coords = torch.full(
        (n_poses, max_n_res, max_n_ats, 3),
        numpy.NaN,
        dtype=torch.float32,
        device=device,
    )

    rf2_coords[rf2_at_is_real] = canonical_form[2][
        rf2_pose_ind_for_atom[rf2_at_is_real],
        rf2_res_ind_for_atom[rf2_at_is_real],
        atom_mapping[rf2_at_is_real],
    ]

    # Find any NaN hydrogens and copy from the H1 instead
    nans = torch.isnan(rf2_coords).any(-1)
    terminal_hs = torch.logical_and(nans, hydro)
    rf2_coords[terminal_hs] = canonical_form[2][
        rf2_pose_ind_for_atom[terminal_hs],
        rf2_res_ind_for_atom[terminal_hs],
        h1s[terminal_hs.any(-1)],
    ]

    suppressed_mapped = torch.full(
        (n_poses, max_n_res, max_n_ats),
        False,
        dtype=torch.bool,
        device=device,
    )
    suppressed_mapped[rf2_at_is_real] = supressed[
        rf2_pose_ind_for_atom[rf2_at_is_real],
        rf2_res_ind_for_atom[rf2_at_is_real],
        atom_mapping[rf2_at_is_real],
    ]
    return rf2_coords, torch.logical_and(
        rf2_at_is_real, torch.logical_not(suppressed_mapped)
    )


def pose_stack_to_rosettafold2(pose_stack, chainlens):
    return pose_stack_to_rosettafold2_with_suppressed(pose_stack, chainlens)[0]


@toolz.functoolz.memoize
def _paramdb_for_rosettafold2() -> ParameterDatabase:
    """Construct the paramdb representing the subset of residues that
    are "used" in Rosettafold2: the canonical amino acids (including the
    two histidine tautomers and the disulfid-bonded cysteine) and
    the canonical n- and c-termini patches.
    """

    from tmol.extern.rosettafold2.chemical import num2aa

    desired_rt_names = sorted(num2aa[:20] + ["HIS_D", "CYD"])
    # hard coding
    desired_variants_display_names = ["nterm", "cterm"]

    return ParameterDatabase.get_default().create_stable_subset(
        desired_rt_names, desired_variants_display_names
    )


@toolz.functoolz.memoize
def _restype_set_for_rosettafold2() -> ResidueTypeSet:
    paramdb = _paramdb_for_rosettafold2()
    return ResidueTypeSet.from_database(paramdb.chemical)


@validate_args
@toolz.functoolz.memoize
def canonical_ordering_for_rosettafold2() -> CanonicalOrdering:
    """Construct the CanonicalOrdering object that will be used for the
    subset of residue types that are used by RoseTTAFold2; this will be
    stable so that the entries in "coords" tensor member of the canonical
    form dictionary will be interpretable indefinitely and thus a
    canonical form dictionary can be serialized to disk and read again
    after an arbitrary amount of time
    """

    paramdb = _paramdb_for_rosettafold2()
    return CanonicalOrdering.from_chemdb(paramdb.chemical)


@validate_args
@toolz.functoolz.memoize
def packed_block_types_for_rosettafold2(device: torch.device) -> PackedBlockTypes:
    """Construct the PackedBlockTypes (PBT) object that will be used for
    the subset of residue types that are used by RoseTTAFold2. For efficiency
    we use the same PBT in the creation of multiple PoseStacks. Thus
    we memoize this function. The user will only interact with this
    function if they are constructing PoseStacks from deserialized
    canonical form objects. See canonical_form_from_rosettafold2 for details.
    """

    restype_set = _restype_set_for_rosettafold2()

    return PackedBlockTypes.from_restype_list(
        restype_set.chem_db, restype_set, restype_set.residue_types, device
    )


@toolz.functoolz.memoize
def _get_rf2_2_tmol_mappings(device: torch.device):
    # TO DO: How should we handle the "UNK" and "MAS" RTs?
    # They list ALA atoms; we could reasonably treat them as ALA
    # but that does not seem the point of having these residues.

    co = canonical_ordering_for_rosettafold2()
    from tmol.extern.rosettafold2.chemical import (
        num2aa,
        aa2long,
    )

    rf2_atom_names_for_name3s = {
        x: [at.strip() if at is not None else "" for at in y]
        for x, y in zip(num2aa, aa2long)
    }

    (rt_map, atname_map, at_is_real) = co.create_src_2_tmol_mappings(
        num2aa, rf2_atom_names_for_name3s, device
    )

    # also want to turn off n-term "H" atoms
    supress_atom_at_nterm = torch.zeros(
        (
            len(num2aa),
            co.max_n_canonical_atoms,
        ),
        dtype=torch.bool,
        device=device,
    )
    for i, i_3lc in enumerate(num2aa):
        if i_3lc not in co.restype_io_equiv_classes:
            continue
        for atname in rf2_atom_names_for_name3s[i_3lc]:
            if atname.strip() == "H":
                tmol_ind = co.restypes_atom_index_mapping[i_3lc][atname.strip()]
                supress_atom_at_nterm[i, tmol_ind] = True
    return rt_map, atname_map, at_is_real, supress_atom_at_nterm


@toolz.functoolz.memoize
def _get_tmol_2_rf2_mappings(device: torch.device):
    """Same logic is the RF2->tmol function, but additionally provides
    a tensor marking the hydrogens in the RF2 index space, as well as
    a tensor giving the tmol 1H index for a residue when indexed by
    the RF2 residue type index
    """

    co = canonical_ordering_for_rosettafold2()
    from tmol.extern.rosettafold2.chemical import (
        num2aa,
        aa2long,
    )

    rf2_atom_names_for_name3s = {
        x: [at.strip() if at is not None else "" for at in y]
        for x, y in zip(num2aa, aa2long)
    }

    (rt_map, atname_map, at_is_real) = co.create_src_2_tmol_mappings(
        num2aa, rf2_atom_names_for_name3s, device
    )

    src_max_n_ats = len(rf2_atom_names_for_name3s[num2aa[0]])
    hydrogens = torch.zeros(
        (
            len(num2aa),
            src_max_n_ats,
        ),
        dtype=torch.bool,
        device=device,
    )
    h_to_h1 = torch.full(
        (len(num2aa),),
        -1,
        dtype=torch.int64,
        device=device,
    )

    # also want to turn off n-term "H" atoms
    supress_atom_at_nterm = torch.zeros(
        (
            len(num2aa),
            co.max_n_canonical_atoms,
        ),
        dtype=torch.bool,
        device=device,
    )

    for i, i_3lc in enumerate(num2aa):
        if i_3lc not in co.restype_io_equiv_classes:
            continue
        for j, atname in enumerate(rf2_atom_names_for_name3s[i_3lc]):
            if atname.strip() == "H":
                tmol_ind = co.restypes_atom_index_mapping[i_3lc][atname.strip()]
                supress_atom_at_nterm[i, tmol_ind] = True

                hydrogens[i, j] = True
                h_to_h1[i] = co.restypes_atom_index_mapping[i_3lc]["1H"]
    return rt_map, atname_map, at_is_real, supress_atom_at_nterm, hydrogens, h_to_h1
